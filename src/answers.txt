Ответы на вопросы:
1. Как вы можете описать процесс распространения событий в JavaScript (Event Propagation)? Расскажите о его основных фазах.
   Какие есть способы применения знаний о фазах распространения событий на практике?
- Начнем с события - действие на странице которое мы можем обработать в JavaScript.
- Распространение события - порядок распространения события по элементам в DOM, в основном используется (всплытие события)
  События всплывают от самого вложенного и будут проходить через всех его родителей, потому что события «всплывают» от
  внутреннего элемента вверх через родителей, подобно тому, как всплывает пузырёк воздуха в воде.
  Обработать события можно 3 способами
  1) Задание атрибута с событием у HTML-элемента
    <button onclick="showMessage()">OK</button>
    function showMessage() {
        alert('1');
        alert('3');
    }
  2) Использование свойств события у Element в DOM
    <button>OK</button>
    let button = document.getElementsByTagName("button")[0];
    button.onclick = function () {
        alert(2);
    }
    элемент доступен по умолчанию в функции
    button.onclick = function () {
    	console.log(this)  // or ( this.innerText ) все свойства элемента
    }
  3) Использование метода addEventListener у Element в DOM
    Добавить слушателя события
    <button>OK</button>
    let button = document.getElementsByTagName("button")[0];
    button.addEventListener("click", (e) => {
        console.log(e.target.innerText);  // OK
    })
    используется когда надо повесить несколько обработчиков на одно событие

    Пример всплытия:
    <div>
      <button>ОК</button>
    </div>
    let button = document.getElementsByTagName("button")[0];
    let div = document.getElementsByTagName("div")[0];
    button.onclick = function () {
        console.log('button clicked');
    }
    div.onclick = function () {
        console.log('div.onclick');
    }
    при нажатии на кнопку получаем сразу обработку 1го событие которое всплывает и обрабатывается 2мя обработчиками
    и получаем сразу 2 строки, (button clicked, div.onclick)
    если нажимаем только на область div то результат будет: div.onclick в консоле

    Запрещает отправку данных на сервер (обычно используется на кнопке c типом submit, событие onsubmit
    event.preventDefault())
    form.onsumbit = (event) => {
      event.preventDefault();
    }

    Запрет распространения события: event.stopPropagation()
    button.onclick = (event) => {
        console.log('button clicked');
        event.stopPropagation()
    }
    div.onclick = () => {
        console.log('div.onclick');
    }
    таким образом мы останавливаем распространение события после обработке события на кнопке (дальше оно не будет всплывать)
    после нажатия на кнопку мы получаем только button clicked, а при нажатии на область div : div.onclick

2. Расскажите, что такое Promise в JavaScript, как он работает, какие основные состояния у него бывают? Каким еще способом можно
   обработать асинхронный код? Какую роль в асинхронности играет событийный цикл (Event Loop)?
-  Promise (Обещание предоставить результат позже не останавливая поток выполнения основной программы)
   можно сказать другими словами это специальный объект, который позволяет выполнить асинхронную операцию и предоставить
   успешный или не успешный результат.
   У Promise есть 3 состояния (Ожидание, исполнен, отклонен)
   const promise = new Promise(((resolve, reject) => {
    if (1) {  // если тут false по получим reject и можно обработать .catch(error => console.log('Error:', error));
      resolve(1);
    } else {
      reject(2);
    }
   }))
   promise.then(number => console.log('Success:', number))

   Есть еще способ обработать асинхронный код - использовать CallBack ,Async/Await, Observables (RxJS).
   JS работает в однопоточном режиме
   Event Loop это такой механизм, который бесконечно проверяет не появился ли асинхронное событие которое надо обработать!!
   добавить его в очередь
   Описание:
   Куча Heap - там у нас объекты , переменные
   Call Stack - куда складируется синхронный код по умочанию(операции, функции.. которые будут выполняться последовательно друг за другом),
   но в рамках этих синхонных задач, могут возникать и асинхронные(события , таймеры, запросы аякс) они представляются интерфейсом webAPI)
   как только js встречает такие операции он их не выполняет сразу. Они попадают в Event Queue(Очередь событий, очередь колбеков)
   Асинхронные задачи ждут освобождения стека и потом задачи заходят поочередно из очереди в Стек и последовательно выполняются.
   let a = 1;
   setTimeout(() => {
       a = 2;
   }, 0)
   console.log(a);
   все три операции попали в стек, но вторая операция содержит внутри асинхронность и она папала в очередь Event Queue
   эта операция будет выполнена после того как выполнятся сихронные операции и очистится стек.
   Если вместо 0 поставить 5000 (5сек) то эта операция будет добавлена в очередь через 5 секунд, но если стек переполнен,
   то операция будет еще ждать пока очистится стек.

3. Что такое ООП, и какие его ключевые принципы вы могли бы описать? При объяснении приводите примеры. Максимально
   подробно расскажите о том, как ООП реализовано в JavaScript.
 - Объектно ориентированное программирование - Подход к разработке и написанию кода, при котором программа рассматривается
   как набор взаимодействующих друг с другом объектов.
   Каждый из таких объектов имеет свои характеристики, свойства и поведение.
   в JS ООП не полноценный и имеет свои особенности
   3 парадигмы ООП (инкапсуляция, полиморфизм, наследование)
   - инкапсуляция
     1. В объект(класс) объеденяються данные и методы которые работают с этими данными.
     2. Сокрытие внутренней структуры от внешнего мира (изменения состояния объекта происходят только обращением к методам
     самого объекта) (объект не должен изменяться с наружи кроме его собственных методов)
     Состояние объекта это значение всех его полей.
     class Employee {
         #companyName = "itlogia"; // Приватное свойство
         constructor(name, lastName, position) {
             this.name = name;
             this.lastName = lastName;
             this.position = position;
         }
         showData() {
             console.log(`Сотрудник ${this.name} ${this.lastName}. ${this.#getWord()}:${this.position}.` +
             ` Компания ${this.#companyName}`);
             console.log(this);
         }
         #getWord() {    // Приватный метод , работает внутри экземпляра(объекта)
             return 'Должность';
         }
     }
     const array = [
         ['Алексей','Малев','Веб-разработчик'],
         ['Иван','Чапаев', 'Веб-разработчик'],
     ]
     array.forEach(item => {
         let employee = new Employee(item[0], item[1], item[2]);
         employee.showData();
         console.log(employee.#getWord());  // получим ошибку, мы не имеем доступа к приватному методу с наружи
     })

   - наследование
     Один класс может наследовать другой класс  (класс может наследовать поля, методы у другого класса), наследовать - переиспользовать.
     в нем появляються поля и методы автоматически после того как он объявляет себя наследником какого то класса.
     JavaScript использует прототипное наследование, а не классовое (хотя с ES6 появился синтаксис классов,
     который является "синтаксическим сахаром" над прототипами).
     Родитель
     class Car {
      year;
      color;
      go() {}
      stop() {}
     }
     Дочерний
     class Porsche extends Car {
      name = 'porsche';
      /*..any..*/
     }
     class BMW extends Car {
      name = 'bmv';
      /*..any..*/
     }
     Экземпляры классов
     let porsche = new Porsche();
     porsche.year = 2022;
     console.log(porsche.name);

     let bmv = new Bmv();
     bmv.year = 2021;
     console.log(bmv.name);

   - полиморфизм
     Свойство ООЛ, которое позволяет использовать, что-то общее для оешения разных задач.
     По факту, одинаковые методы могут давать разный результат для разных объектов.
     class Car {
      /*...*/
      go() {}
     }
     class Porsche extends Car {
       /*..any..*/
       go() {}
     }
     class Bmv extends Car {
       /*..any..*/
       go() {}
     }

     Геттеры и Сеттеры
     Специальные свойства которые представляют из себя функции, но используются как свойства при работе с объектом
     class Porsche extends Car {
      modelName = '911';
      get model() {
        return this.modelName;
      }
      set model(name) {
        // ...
        this.modelName = name;
      }
     }
      let porsche = new Porsche();
      console.log(porsche.model);
      porsche.model = 'panamera'

      Прототипы в JS
      Механизм в JS, который позволяет объектам наследовать свойства и методы друг друга
      Множественное наследование, сначала ищется в основном объекте потом выше стоящего Объекта и так по цепочке как в матрешке..
      class Person {
         constructor(name, lastName, position) {
             this.name = name;
             this.lastName = lastName;
             this.position = position;
         }
         speak() {}
      }
      const employees = [
          ['Алексей','Малев','Веб-разработчик'],
          ['Иван','Чапаев', 'Веб-разработчик'],
      ]
      let employee1 = new Person(employees[0][0], employees[0][1], employees[0][2]);
      Person.prototype.check = () => {
          alert(3);
      }
      employee1.check(); работает ))   (этот экземпляр создан из класса Person)

      Создание нового метода используя прототип (расширение)
      Date.prototype.addDays = function (days) {
          const date = new Date();
          date.setDate(date.getDate() + days);
          return date;
      }
      const date = new Date();
      console.log('Date:  ' + date.addDays(5))

3.  Опишите максимально детально, как браузер обрабатывает URL, начиная с момента его ввода в адресную строку и заканчивая
    отображением страницы. Какие технологии позволяют ускорить процесс? Какие проблемы (безопастность, междоменное
    взаимодействие) могут возникать в процессе?
    - Парсинг URL
      protocol: "https:",
      hostname: "www.example.com",
      port: "443",
      pathname: "/path",
      search: "?query=1",
      hash: "#section"
    Проверка синтаксиса URL, Проверка опасных символов, Если не URL то в поиск
    - Проверка кэшей
    - DNS Resolution (опрашиваем DNS начиная со своего кеша запросов и потом тот что записан в ОS)
    - Установка TCP соединения (Handshake) обмен пакетамиЮ для установки соеденения и установка канала передачи данных
    - Отправка HTTP запроса
    - Получение ответа и обработка ошибок
    - Получение HTML, парсинг и построение DOM
    - Загрузка доп. ресурсов (шрифты, картинки и тд)
    - работа JS
    Далее идут технологии оптимизации загрузки, отимизация рендеренга

    Потом CORS Междоменное взаимодействие
    (механизм безопасности в браузерах, который позволяет или запрещает веб-странице делать запросы к другому домену)
    Внутренний запрос (разрешен всегда)
    -Вы на сайте: https://mysite.ru
    -Делаете запрос на: https://mysite.ru/api/products
    -РАБОТАЕТ! Это тот же домен
    Внешний запрос (нужен CORS)
    -Вы на сайте: https://mysite.ru
    -Делаете запрос на: https://api.payment.com/process
    -БЛОКИРУЕТСЯ! Это разные домены

    Куки и сессии
    Безопастность и произодительность.





